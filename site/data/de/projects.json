{
	"projects": [
		{
			"title": "matt-daemon",
			"description": "Implementierung eines echten UNIX-Daemons in C++11: Hintergrundausführung mit Root-Rechten, Lauschen auf Port 4242 und gleichzeitige Verwaltung von maximal drei Clients. Jede Aktion, Nachricht oder Signal wird mit Zeitstempel in /var/log/matt_daemon/ protokolliert und sorgt für Nachvollziehbarkeit und Systemrobustheit.",
			"detail": "Ein Einführungsprojekt in daemonisierte Prozesse unter Linux. Das Programm MattDaemon arbeitet als eigenständiger Netzwerkdienst: sichere Initialisierung (fork, setsid, flock), persistenter Socket-Listener, saubere Signalbehandlung und Sperre über /var/lock/matt_daemon.lock. Client-Interaktionen werden protokolliert, der Befehl quit löst einen kontrollierten Shutdown aus. Die Architektur basiert auf modularen Klassen (Dateiverwaltung, Logger Tintin_reporter, Server, Daemonizer), getestet unter Debian via Docker mit persistenten Volumes für die Logs.",
			"technologies": [
				"Linux",
				"C++",
				"Daemon",
				"Make"
			],
			"date": "November 2025",
			"repo": "https://github.com/aceyzz/matt-daemon",
			"logo": "/assets/projects/cplusplus.png",
			"banner": "/assets/projects/banner/matt-daemon.png",
			"category": [
				"Projekte 42",
				"Systeme & DevOps",
				"Objektorientierte Programmierung"
			]
		},
		{
			"title": "little-penguin-1",
			"description": "Serie von Kernel-Entwicklungsübungen unter Linux: Kernel von Linus kompilieren und booten, Module schreiben/anpassen, Automatisierung mit udev, Schnittstellen bereitstellen (misc, debugfs) und reproduzierbare Nachweise liefern.",
			"detail": "Praktischer Einstieg in die Kernel-Entwicklung: Kompilieren/Booten von Kerneln (mainline & linux-next), Schreiben einfacher Module und Treiber, Integration mit Userspace (udev, procfs, debugfs, misc). Ziele: Beherrschung von Toolchain und Workflow (Konfiguration, Build, Patch), strikte Einhaltung des Linux Kernel Coding Style und Erstellung reproduzierbarer Nachweise (Logs, Patches). Das Projekt konzentriert sich auf Low-Level-Mechanismen und Kernel↔Userspace-Schnittstellen ohne zusätzliche Abstraktionen.",
			"technologies": [
				"Linux",
				"C",
				"Bash",
				"Make",
				"GRUB",
				"Systemd / SysV"
			],
			"date": "Oktober 2025",
			"repo": "https://github.com/aceyzz/little-penguin-1",
			"logo": "/assets/projects/linux.png",
			"banner": "/assets/projects/banner/little-penguin-1.png",
			"category": [
				"Projekte 42",
				"Systeme & DevOps",
				"Niedrig-Level-Programmierung"
			]
		},
		{
			"title": "ft_linux",
			"description": "Eine Linux-Distribution von Grund auf neu erstellen: Kernel kompilieren und installieren, Partitionen, Userspace und ein bootfähiges System vorbereiten.",
			"detail": "Vorbereitung einer Build-Umgebung, Erstellung von Partitionen (/boot, /, swap), Kompilierung einer Toolchain und Aufbau eines minimalen Systems. Kompilieren und Installieren eines Linux-Kernels (Version ≥ 4.0), Installation der Quellen, Konfiguration von udev, Installation eines Bootloaders, Einrichtung eines Init-Systems (SysV oder systemd) und Sicherstellung eines sauberen Systemstarts. Alle Vorgaben des Projekts werden strikt eingehalten (Partitionen, Namen, Pfade, udev vorhanden, Hostname). Die Arbeit ist auf einer VM reproduzierbar, mit Makefile/Skripten und Build-Dokumentation.",
			"technologies": [
				"Linux",
				"C (Kernel-Kompilierung)",
				"Bash",
				"Make",
				"GRUB",
				"Systemd / SysV",
				"Ext4 (Partitionen)",
				"Toolchain (gcc/ld/binutils)"
			],
			"date": "Oktober 2025",
			"repo": "https://github.com/aceyzz/ft_linux",
			"logo": "/assets/projects/linux.png",
			"banner": "/assets/projects/banner/ft_linux.png",
			"category": [
				"Projekte 42",
				"Systeme & DevOps",
				"Niedrig-Level-Programmierung"
			]
		},
		{
			"title": "ft_ssl_md5",
			"description": "Implementierung der Hash-Algorithmen MD5 und SHA-256 in C: Lesen aus Dateien oder stdin, Ausgabeformat kompatibel mit OpenSSL.",
			"detail": "Entwicklung eines ft_ssl-Programms, das mit MD5 und SHA-256 Dateien oder die Standardeingabe hashen kann. Die Ausgabeformate werden strikt eingehalten (echo/print-Stil, Flags -p/-q/-r/-s), Padding, Blockaufteilung, Endianness werden korrekt behandelt und die Ergebnisse sind identisch zu OpenSSL/sha256sum/md5sum. Robuster Code (Fehlerbehandlung, fehlende Dateien), optimiert und durch vergleichende Unit-Tests mit Standardtools abgedeckt. Die Implementierung zeigt Verständnis für Bitoperationen, Standardkonstanten und die Struktur von Hash-Algorithmen.",
			"technologies": [
				"C",
				"Bitoperationen",
				"Hash-Algorithmen",
				"Linux",
				"Datei-IO",
				"MD5",
				"SHA-256",
				"OpenSSL",
				"Make"
			],
			"date": "Oktober 2025",
			"repo": "https://github.com/aceyzz/ft_ssl_md5",
			"logo": "/assets/projects/ssl.png",
			"banner": "/assets/projects/banner/ft_ssl_md5.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Cybersicherheit & Netzwerk",
				"Projekte 42"
			]
		},
		{
			"title": "ft_malcolm",
			"description": "Minimale Implementierung eines ARP-Spoofings in C: Lauschen auf eine ARP-Broadcast-Anfrage des Ziels für die Quell-IP, Senden einer einzigen gefälschten ARP-Reply. Das Projekt dient dem Verständnis von Layer 2/Ethernet, ARP (RFC 826) und der grundlegenden Man-in-the-Middle-Attacke.",
			"detail": "Ein Einführungsprojekt in die Cybersicherheit. Das Programm nimmt 4 obligatorische Argumente in dieser Reihenfolge: Quell-IP, Quell-MAC, Ziel-IP, Ziel-MAC. Es wartet gezielt auf eine ARP-Broadcast-Anfrage des Ziels für die Quell-IP, erstellt und sendet dann eine einzige ARP-Reply (Ethernet+ARP) an das Ziel und beendet sich anschließend sauber. Das Programm behandelt Fehler, Signale und hält sich an die Vorgaben der Low-Level-Programmierung. Implementierungsseitig: automatische Auswahl der Schnittstelle anhand der Quell-IP, strikte Validierung des empfangenen Frames, Konstruktion einer gepackten Antwort (sha/spa/tha/tpa) und gezieltes Senden; lesbare Logs, Verbose-Modus mit Hex-Dump, Makefile und ein Docker-Labor (Angreifer/Opfer + tcpdump/wireshark) für die Demo.",
			"technologies": [
				"C",
				"Ethernet (L2)",
				"Linux",
				"Raw Sockets und Filterung",
				"ARP (RFC 826)",
				"Docker & Docker Compose",
				"Wireshark",
				"MITM-Attacke"
			],
			"date": "Oktober 2025",
			"repo": "https://github.com/aceyzz/ft_malcolm",
			"logo": "/assets/projects/malcolm.png",
			"banner": "/assets/projects/banner/malcolm.png",
			"category": [
				"Cybersicherheit & Netzwerk",
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "ft_linear_regression",
			"description": "Implementierung einer linearen Regression (Gradientenabstieg) zur Schätzung des Autopreises anhand des Kilometerstands, mit Trainings- und Vorhersageprogrammen, Visualisierungen und Metriken.",
			"detail": "Ein Einführungsprojekt in das maschinelle Lernen, bei dem ein einfaches lineares Regressionsmodell auf einem km/preis-Datensatz trainiert und ein Preis anhand eines gegebenen Kilometerstands vorhergesagt wird. Das 42-Thema verlangt zwei separate Programme (train & predict), die Verwendung des Gradientenabstiegs und das Verbot von Bibliotheken, die 'alles erledigen', mit Boni wie dem Zeichnen der Daten/der Linie und einer Genauigkeitsberechnung. Implementierungsseitig: Robustes CSV-Parsing mit Validierungen (unveränderlicher Datensatz, Umgang mit leeren Zeilen/Fehlern), Min-Max-Normalisierung des Features, Training durch Gradientenabstieg mit periodischen Logs, Konvergenztoleranz und Schutzmaßnahmen gegen Divergenz, Speicherung der Parameter in einer JSON-Datei (`theta0`, `theta1`, `x_min`, `x_max`) und interaktiver CLI-Prädiktor. Ein Bewertungsmodul berechnet MAE/RMSE/MSE/R² und ein optionaler Bonus zeigt eine Matplotlib-Grafik (Punkte, Modelllinie, Gültigkeitsbereich und Vorhersageannotation).",
			"technologies": [
				"Python 3",
				"CLI",
				"Matplotlib",
				"CSV",
				"JSON",
				"Dataclasses",
				"Lineare Regression",
				"Gradientenabstieg",
				"Min-Max-Normalisierung",
				"MAE / MSE / RMSE / R²"
			],
			"date": "Oktober 2025",
			"repo": "https://github.com/aceyzz/ft_linear_regression",
			"logo": "/assets/projects/ftlr.png",
			"banner": "/assets/projects/banner/ftlr.png",
			"category": [
				"KI & Daten",
				"Projekte 42"
			]
		},
		{
			"title": "Swifty-Proteins",
			"description": "iOS/macOS-App in SwiftUI zur Visualisierung von 3D-Proteinen aus der Protein Data Bank mit biometrischer Authentifizierung.",
			"detail": "Swifty-Proteins ist ein fortgeschrittenes mobiles Projekt der Schule 42, das die Einführung in 3D-Rendering und moderne mobile Frameworks zum Ziel hat. Die App nutzt die PDB-Datenbank (Protein Data Bank), um Moleküle und Liganden in 3D mit SceneKit darzustellen. Sie enthält ein Authentifizierungssystem mit Biometrie (TouchID/FaceID), Benutzerverwaltung (Erstellung und Login), eine Ligandenliste mit Suchfunktion, einen interaktiven 3D-Viewer (Zoom, Rotation, Tooltips zu Atomen, CPK-Färbung, Ball-and-Stick-Darstellung) und Social-Sharing-Funktionen. Boni ermöglichen weitere Visualisierungsstile oder alternative Modelle. Das Projekt verbindet Strukturbiologie und native mobile Entwicklung für ein interaktives und lehrreiches Erlebnis.",
			"technologies": [
				"Swift",
				"SwiftUI",
				"iOS",
				"macOS",
				"SceneKit",
				"CoreData",
				"Keychain",
				"Biometrie (TouchID/FaceID)",
				"REST API",
				"RCSB Protein Data Bank"
			],
			"date": "September 2025",
			"repo": "https://github.com/aceyzz/swifty-proteins",
			"logo": "/assets/projects/swifty-proteins.png",
			"banner": "/assets/projects/banner/swifty-p.png",
			"category": [
				"Mobile Entwicklung",
				"Webentwicklung",
				"KI & Daten",
				"Objektorientierte Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Matcha",
			"description": "Entwicklung einer vollständigen Dating-Website mit Profilen, Matching, Echtzeit-Chat und Benachrichtigungen, durchgehend sicher.",
			"detail": "Matcha ist ein Webprojekt der Schule 42, bei dem eine moderne und sichere Dating-App entwickelt wird. Nutzer können sich registrieren, anmelden, ihr Profil vervollständigen (Geschlecht, Präferenzen, Biografie, Interessen mit Tags, Fotos) und sehen, wer ihr Profil angesehen oder 'geliked' hat. Die App enthält eine Matching-Engine basierend auf Geolokalisierung, gemeinsamen Interessen und einem 'Fame Rating'. Sie bietet erweiterte Suche nach Kriterien (Alter, Standort, Tags), Profilansicht mit Besuchshistorie, Verwaltung von Likes/Matches und einen Echtzeit-Chat mit Sofortbenachrichtigungen (Likes, Ansichten, Nachrichten). Boni umfassen Authentifizierung über soziale Netzwerke (Omniauth), Fotoimport, interaktive Karten und sogar geplante Treffen. Alles ist vollständig abgesichert (verschlüsselte Passwörter, Formularvalidierung, Schutz vor SQL-Injection und XSS).",
			"technologies": [
				"Golang",
				"PostgreSQL",
				"JavaScript",
				"Docker",
				"Python",
				"HTML",
				"CSS",
				"Echtzeit-Chat",
				"REST API",
				"OAuth/Omniauth"
			],
			"date": "September 2025",
			"repo": "https://github.com/cduffaut/matcha",
			"logo": "/assets/projects/matcha.png",
			"banner": "/assets/projects/banner/matcha.png",
			"category": [
				"Webentwicklung",
				"KI & Daten",
				"Objektorientierte Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Tokenizer",
			"description": "Web3-Projekt zur Erstellung und Bereitstellung eines benutzerdefinierten BEP-20-Tokens auf der BNB-Blockchain mit Dokumentation und Tests.",
			"detail": "Tokenizer ist ein Blockchain-Projekt der Schule 42 in Partnerschaft mit BNB Chain. Ziel ist die Entwicklung und Bereitstellung eines benutzerdefinierten digitalen Tokens (mit '42' im Namen) auf einer öffentlichen, kompatiblen Blockchain, hier der BNB Smart Chain. Das Projekt umfasst die Entwicklung des Smart Contracts (ERC-20 oder BEP-20 Standard), das Schreiben eines ausführlichen READMEs, die Bereitstellung auf dem Testnet und die Veröffentlichung des Tokens auf einem Explorer (BscScan, Blockscan). Die Repository-Architektur enthält einen `code`-Ordner für die Verträge, einen `deployment`-Ordner für Bereitstellungsskripte und einen `documentation`-Ordner für Erklärungen und das Whitepaper. Sicherheit und Privilegienverwaltung (Eigentum, Pause, Burn, Mint je nach Wahl) sind essenziell. Als Bonus kann ein Multisignatur-System die Transaktionssicherheit erhöhen. Das Projekt vermittelt Kenntnisse in Solidity, Entwicklungstools (Hardhat, Truffle, Remix) und dem Web3-Ökosystem.",
			"technologies": [
				"Solidity",
				"Node.js",
				"TypeScript",
				"JavaScript",
				"Hardhat",
				"Ethers.js",
				"BNB Smart Chain",
				"Metamask",
				"Web3",
				"Smart Contracts"
			],
			"date": "September 2025",
			"repo": "https://github.com/aceyzz/tokenizer",
			"logo": "/assets/projects/tokenizer.png",
			"banner": "/assets/projects/banner/tokenizer.png",
			"category": [
				"KI & Daten",
				"Objektorientierte Programmierung",
				"Projekte 42",
				"Cybersicherheit & Netzwerk"
			]
		},
		{
			"title": "Inception of Things",
			"description": "Einführungsprojekt zu Kubernetes mit Vagrant, K3s, K3d und GitOps (Argo CD), entwickelt im Rahmen der Schule 42.",
			"detail": "Dieses Projekt dient dazu, sich aus Entwicklersicht mit Kubernetes vertraut zu machen. Zunächst werden mit Vagrant virtuelle Maschinen erstellt (Teil 1). Anschließend wird ein K3s-Cluster bereitgestellt und mehrere Anwendungen mit einem Ingress darauf ausgeführt (Teil 2). Der letzte Schritt beinhaltet K3d zusammen mit Argo CD, um eine CI/CD direkt aus einem GitHub-Repository einzurichten (Teil 3). Ein optionaler Bonus besteht darin, GitLab + CI/CD mit Argo CD zu integrieren, um Anwendungen automatisch auf dem Cluster zu synchronisieren.",
			"technologies": [
				"Vagrant",
				"K3s",
				"K3d",
				"Kubernetes",
				"Ingress",
				"Docker",
				"Argo CD",
				"GitOps",
				"CI/CD",
				"GitLab"
			],
			"date": "September 2025",
			"repo": "https://github.com/aceyzz/inception-of-things",
			"logo": "/assets/projects/iot.png",
			"banner": "/assets/projects/banner/iot.png",
			"category": [
				"Projekte 42",
				"Systeme & DevOps"
			]
		},
		{
			"title": "Swifty-Companion",
			"description": "iOS-App in SwiftUI, die die 42-API nutzt, um Informationen über einen Studenten anzuzeigen.",
			"detail": "Swifty-Companion ist ein mobiles Projekt der Schule 42. Es handelt sich um eine iOS-App, die in SwiftUI entwickelt wurde und die offizielle 42-API über OAuth2 (Intranet) nutzt, um dynamisch Nutzerdaten anzuzeigen. Die App bietet eine Startseite mit Suchfeld (42-Login), eine Profilansicht (Login, Level, Standort in der Schule, Coalition, absolvierte Projekte, Fähigkeiten, Profilfoto), eine reaktive Architektur für verschiedene Bildschirmgrößen und eine robuste Fehlerbehandlung (Login nicht gefunden, API nicht verfügbar, Netzwerk- oder Authentifizierungsprobleme). Boni wie das automatische Aktualisieren des OAuth2-Tokens bei Ablauf und die automatische Wiederverbindung sind möglich, wenn der Pflichtteil perfekt ist. Die Sicherheitsbestimmungen werden eingehalten, insbesondere mit `.env` für API-Schlüssel.",
			"technologies": [
				"Swift",
				"SwiftUI",
				"OAuth2",
				"REST API",
				"Responsive UI",
				"iOS"
			],
			"date": "September 2025",
			"repo": "https://github.com/aceyzz/swifty-companion",
			"logo": "/assets/projects/swifty.png",
			"banner": "/assets/projects/banner/swifty.png",
			"category": [
				"Projekte 42",
				"Mobile Entwicklung",
				"Objektorientierte Programmierung"
			]
		},
		{
			"title": "BibleFlow",
			"description": "Mobile Swift-App für das Offline-Lesen der Bibel, mehrsprachig, für iOS und macOS.",
			"detail": "BibleFlow ist eine mobile App in Swift, die ein vollständiges Bibelleserlebnis ohne Internetverbindung bietet. Sie unterstützt mehrere Sprachen für die Bibeltexte, eine adaptive Oberfläche für iOS und macOS sowie eine flüssige Navigation zwischen Büchern, Kapiteln und Versen. Die App legt Wert auf Barrierefreiheit und Offline-Performance. Das Projekt umfasst die Verwaltung verschiedener Übersetzungen, die lokale Speicherung der Bibelversionen und eine moderne, responsive UI auf Basis von SwiftUI (oder UIKit), mit zukünftigen Funktionen wie Suche, Favoriten, Anmerkungen und Datensynchronisation zwischen Geräten.",
			"technologies": [
				"Swift",
				"SwiftUI",
				"Core Data (lokale Speicherung)",
				"iOS",
				"macOS",
				"Mehrsprachig",
				"Offline"
			],
			"date": "In Arbeit",
			"repo": null,
			"logo": "/assets/projects/bible.png",
			"banner": "/assets/projects/banner/bible.png",
			"category": [
				"KI & Daten",
				"Objektorientierte Programmierung",
				"Mobile Entwicklung"
			]
		},
		{
			"title": "BTCpay Server – Krypto-Zahlungen",
			"description": "Bereitstellung eines selbstgehosteten BTCpay-Servers zur Annahme von Zahlungen in Kryptowährungen (BTC, XMR, LTC, DOGE, DASH) souverän, sicher und ohne Zwischenhändler.",
			"detail": "Einrichtung von BTCpay Server auf einem On-Prem-Debian-Server via Docker, mit sicherem Reverse Proxy und geschütztem Fernzugriff. Wallet-Konfiguration für mehrere Kryptowährungen (Bitcoin, Monero, Litecoin, Dogecoin, Dash), dynamische Rechnungserstellung, Integration eines vollständigen Knotens für jede Währung und lokale Schlüsselverwaltung ohne Drittanbieter. Das Projekt stärkt die finanzielle Autonomie und setzt fortgeschrittene Konzepte der Dezentralisierung, Sicherheit und digitalen Souveränität um. Besonderes Augenmerk liegt auf der Infrastruktur-Resilienz, Netzwerksicherheit und Benutzererfahrung für Händler und Kunden.",
			"technologies": [
				"Debian",
				"Docker",
				"Docker Compose",
				"BTCpay Server",
				"Nginx Reverse Proxy",
				"Bitcoin Full Node",
				"XMR Wallet",
				"LTC Wallet",
				"DOGE Wallet",
				"DASH Wallet",
				"Tailscale",
				"Selbsthosting",
				"Netzwerksicherheit",
				"Kryptowährungen"
			],
			"date": "Juni 2025",
			"repo": null,
			"logo": "/assets/projects/crypto.png",
			"banner": "/assets/projects/banner/btcpay.png",
			"category": [
				"Systeme & DevOps",
				"Cybersicherheit & Netzwerk"
			]
		},
		{
			"title": "Persönliches HomeLab",
			"description": "Bereitstellung eines vollständigen HomeLabs auf Debian-Server mit KI-, DevOps-, Virtualisierungs- und Sicherheitsdiensten über privates VPN.",
			"detail": "Installation und Konfiguration eines Debian-Servers auf einem recycelten physischen Gerät zur Bereitstellung eines persönlichen HomeLabs über CasaOS. Einrichtung von Tailscale für sicheren und verschlüsselten Fernzugriff. Bereitstellung und Verwaltung fortschrittlicher Dienste über Docker: lokaler KI-Chatbot (Ollama CPU + Open WebUI), Entwicklungsumgebung (VSCode Server), Produktivitätstools (Ghostfolio, Wallos, LibreTranslate, Stirling PDF, ConvertX, IT Tools), Mediaplayer (Navidrome), Remote-Desktop (Webtop) und ein maßgeschneiderter YouTube Downloader. Zentralisierung der Logs über Dozzle. Alle Dienste sind containerisiert, isoliert und nur über VPN zugänglich. Das Projekt setzt Best Practices in Systemadministration, Netzwerksicherheit, Virtualisierung und DevOps um und nutzt moderne Tools im Selbsthosting.",
			"technologies": [
				"Debian",
				"CasaOS",
				"Docker",
				"Docker Compose",
				"Reverse Proxy",
				"Ollama",
				"Open WebUI",
				"VSCode Server",
				"Gitea",
				"Dozzle",
				"Tailscale",
				"Telegram Bot API",
				"Wallos",
				"Ghostfolio",
				"LibreTranslate",
				"Stirling PDF",
				"Excalidraw",
				"KASM Workspaces",
				"Netzwerksicherheit",
				"Lokales Monitoring"
			],
			"date": "April 2025",
			"repo": null,
			"logo": "/assets/projects/homelab.png",
			"banner": "/assets/projects/banner/homelab.png",
			"category": [
				"Systeme & DevOps",
				"Cybersicherheit & Netzwerk"
			]
		},
		{
			"title": "Automatisierter Trading-Bot",
			"description": "Entwicklung eines Krypto-Trading-Bots mit Freqtrade, einer individuellen DCA-Strategie und einer UI über Cloudflare Tunnel.",
			"detail": "Entwicklung eines automatisierten Trading-Bots auf Basis von Freqtrade mit einer fortschrittlichen DCA-Strategie (Dollar-Cost Averaging), optimiert für eine jährliche Mindestrendite von 15%. Der Bot überwacht Markttrends und setzt intelligente Kauf- und Verkaufsorders basierend auf technischen Indikatoren. Die Performance wurde durch Backtests über mehrere Jahre validiert: 2022 (15,05%), 2023 (17,83%) und 2024 (16,42%). Die Anwendung läuft auf einem On-Premise-Linux-Server und gewährleistet volle Kontrolle über die Infrastruktur. Virtualisierung via Docker sorgt für optimale Isolierung und erleichtert Updates und Skalierbarkeit. Eine Benutzeroberfläche über Freqtrade UI ermöglicht die Echtzeitüberwachung offener Positionen, Performance und Transaktionshistorie. Ein Cloudflare-Tunnel sichert den Fernzugriff auf die Oberfläche und gewährleistet eine reibungslose Verwaltung des Bots ohne direkte Internet-Exposition.",
			"technologies": [
				"Python",
				"Freqtrade",
				"PostgreSQL",
				"Docker",
				"Binance API",
				"Pandas",
				"NumPy",
				"Telegram Bot API",
				"Freqtrade UI",
				"Cloudflare Tunnel",
				"Reverse Proxy",
				"Raspberry Pi",
				"Virtualisierung"
			],
			"date": "Februar 2025",
			"repo": null,
			"logo": "/assets/projects/cryptobot.png",
			"banner": "/assets/projects/banner/bot.png",
			"category": [
				"KI & Daten",
				"Systeme & DevOps"
			]
		},
		{
			"title": "Portfolio-Website",
			"description": "Erstellung eines interaktiven Portfolios zur Präsentation meiner Projekte.",
			"detail": "Entwicklung einer interaktiven Website zur Präsentation meiner beruflichen und persönlichen Projekte. Die Seite wird auf Azure Static Web Apps gehostet, um optimale Leistung und einfache Bereitstellung zu gewährleisten. Die Domain wird von Infomaniak verwaltet. Ein benutzerdefinierter Routing-Service in reinem JavaScript sorgt für eine flüssige Navigation zwischen den verschiedenen Bereichen der Seite und garantiert das Prinzip der Single Page Application. Das Design ist minimalistisch und modern dank picoCSS.",
			"technologies": [
				"HTML",
				"CSS",
				"JavaScript",
				"Azure Static Web Apps",
				"picoCSS",
				"Github CI/CD"
			],
			"date": "November 2024",
			"repo": "https://github.com/aceyzz/personnal_portfolio",
			"logo": "/assets/projects/portfolio.png",
			"banner": "/assets/projects/banner/portfolio.png",
			"category": [
				"Webentwicklung"
			]
		},
		{
			"title": "Cloud-1",
			"description": "Implementierung einer vollständigen WordPress-Umgebung mit Docker Compose auf Azure.",
			"detail": "Dieses Projekt besteht darin, eine vollständige WordPress-Umgebung mit Docker-Containern für WordPress, MariaDB, phpMyAdmin und Nginx auf einer Azure-VM zu erstellen. Die Container werden mit Docker Compose orchestriert und die Bereitstellung sowie Konfiguration mit Ansible automatisiert. Die Umgebung verwendet SSL-Zertifikate zur Sicherung der Verbindungen und gewährleistet die Datenpersistenz für MariaDB und WordPress.",
			"technologies": [
				"Docker",
				"Docker Compose",
				"Ansible",
				"Azure",
				"WordPress",
				"MariaDB",
				"phpMyAdmin",
				"Nginx",
				"SSL"
			],
			"date": "November 2024",
			"repo": "https://github.com/aceyzz/cloud-1",
			"logo": "/assets/projects/cloud-1.png",
			"banner": "/assets/projects/banner/cloud-1.png",
			"category": [
				"Systeme & DevOps",
				"Projekte 42"
			]
		},
		{
			"title": "Libft",
			"description": "Die wichtigsten Funktionen der Standard-C-Bibliothek nachbauen.",
			"detail": "Entwicklung einer eigenen Bibliothek durch Nachbau mehrerer grundlegender Funktionen der Standard-C-Bibliothek mit Fokus auf Best Practices und effizientes Speichermanagement.",
			"technologies": [
				"C",
				"Makefile"
			],
			"date": "Oktober 2023",
			"repo": "https://github.com/aceyzz/Libft",
			"logo": "/assets/projects/libft.png",
			"banner": "/assets/projects/banner/libft.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Get Next Line",
			"description": "Eine Zeile aus einer Datei optimiert lesen.",
			"detail": "Entwicklung einer Funktion, die Zeile für Zeile aus einer Datei oder Standardeingabe liest und dabei Buffer zur Leistungsoptimierung verwendet.",
			"technologies": [
				"C"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/Get_next_line",
			"logo": "/assets/projects/gnl.png",
			"banner": "/assets/projects/banner/gnl.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Ft_printf",
			"description": "Die printf-Funktion der Standard-C-Bibliothek nachbauen.",
			"detail": "Entwicklung einer eigenen Version der printf-Funktion mit Unterstützung mehrerer Formate und Spezifikationen sowie effizientem Speichermanagement.",
			"technologies": [
				"C"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/Ft_printf",
			"logo": "/assets/projects/printf.png",
			"banner": "/assets/projects/banner/ftprintf.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Born2BeRoot",
			"description": "Eine sichere virtuelle Maschine konfigurieren.",
			"detail": "Installation und Konfiguration einer sicheren virtuellen Maschine auf Debian-Basis. Das Projekt umfasst wesentliche Aspekte der Systemverwaltung, darunter das Herunterladen und Installieren der VM, die Erstkonfiguration, die Verbindung über SSH und die Einrichtung strikter Sicherheitsrichtlinien. Behandelte Konzepte sind Virtualisierung mit VirtualBox, Benutzer- und Rechteverwaltung, Installation und Konfiguration von Diensten wie SSH und UFW sowie die Einrichtung robuster Passwortregeln und Sicherheitsprotokolle.",
			"technologies": [
				"Linux",
				"VirtualBox",
				"Debian",
				"SSH",
				"UFW",
				"Sudo",
				"Crontab"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/Born2beRoot",
			"logo": "/assets/projects/b2r.png",
			"banner": "/assets/projects/banner/b2r.png",
			"category": [
				"Systeme & DevOps",
				"Cybersicherheit & Netzwerk",
				"Projekte 42"
			]
		},
		{
			"title": "Push_Swap",
			"description": "Ein Sortieralgorithmus mit begrenzten Operationen implementieren.",
			"detail": "Das Projekt push_swap besteht darin, ein C-Programm zu entwickeln, das eine Liste von Ganzzahlen als Kommandozeilenargument nimmt und eine Operationssequenz ausgibt, mit der diese Zahlen optimal sortiert werden. Das Programm verwendet zwei Stapel, 'a' und 'b', und eine begrenzte Anzahl von Stapeloperationen zum Sortieren. Zulässige Operationen sind Swaps, Rotationen und Pushes zwischen den Stapeln. Ziel ist es, die Gesamtzahl der Operationen zu minimieren.",
			"technologies": [
				"C"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/Push_swap",
			"logo": "/assets/projects/pushswap.png",
			"banner": "/assets/projects/banner/pushswap.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Minitalk",
			"description": "Entwicklung einer Client-Server-Anwendung zum Nachrichtenaustausch über Unix-Signale.",
			"detail": "Entwicklung eines einfachen Client-Server-Kommunikationssystems unter Verwendung von Unix-Signalen als Übertragungsmedium. Der Client sendet eine Nachricht an den Server, der sie empfängt und anzeigt. Der Client wandelt jedes Zeichen der Nachricht in eine Bitfolge um und sendet sie über die Signale SIGUSR1 und SIGUSR2 an den Server. Der Server rekonstruiert die Nachricht aus den empfangenen Bits und zeigt sie an. Der Server bestätigt den Empfang jeder Nachricht durch das Senden eines Signals an den Client. Das Projekt enthält Bonusfunktionen wie die Unterstützung von Unicode-Zeichen.",
			"technologies": [
				"C",
				"Unix",
				"Signale"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/Minitalk",
			"logo": "/assets/projects/minitalk.png",
			"banner": "/assets/projects/banner/minitalk.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "So_Long",
			"description": "Entwicklung eines 2D-Spiels in C auf Basis einer Grafikbibliothek.",
			"detail": "Willkommen bei So_Long, einem 2D-Spielprojekt in C im Rahmen eines Programmierlernprogramms. Das Projekt konzentriert sich auf die Entwicklung eines einfachen Spiels mit der Grafikbibliothek MinilibX. Ziel ist es, ein Spiel zu erstellen, in dem ein Spieler sich durch eine Karte bewegt, Objekte sammelt, Hindernissen ausweicht und den Ausgang erreicht. Das Spiel beinhaltet die Verwaltung von Benutzereingaben, Grafik-Rendering und die Verwaltung von Spielelementen wie Spieler, Objekte, Hindernisse und Ausgang. Das Projekt umfasst Event-Handling, Animationen und Interaktionen mit der Umgebung.",
			"technologies": [
				"C",
				"MinilibX",
				"Grafik"
			],
			"date": "November 2023",
			"repo": "https://github.com/aceyzz/So_long",
			"logo": "/assets/projects/solong.png",
			"banner": "/assets/projects/banner/solong.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Philosophers",
			"description": "Simulation eines klassischen Algorithmusproblems mit Multithreading.",
			"detail": "Dieses Programm simuliert das klassische Problem der speisenden Philosophen mit Threads und Mutexen in C. Die Philosophen wechseln zwischen Essen, Nachdenken und Schlafen. Sie benutzen Gabeln zum Essen und legen sie nach dem Essen zurück auf den Tisch. Die Philosophen dürfen nie verhungern, und die Simulation endet, wenn ein Philosoph verhungert. Das Programm muss ohne globale Variablen geschrieben werden und Argumente wie die Anzahl der Philosophen, Zeitlimits für Essen, Schlafen und Sterben sowie ein optionales Argument für die Anzahl der Mahlzeiten pro Philosoph akzeptieren. Das Programm muss die Ereignisaufzeichnung verwalten und sicherstellen, dass die Philosophen nicht verhungern. Die Implementierung kann entweder mit Threads und Mutexen oder mit Prozessen und Semaphoren erfolgen (in meinem Fall Threads & Mutex).",
			"technologies": [
				"C",
				"Multithreading"
			],
			"date": "Dezember 2023",
			"repo": "https://github.com/aceyzz/Philosophers",
			"logo": "/assets/projects/philo.png",
			"banner": null,
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Minishell",
			"description": "Entwicklung einer minimalistischen Shell inspiriert von Bash.",
			"detail": "Im Projekt 'Minishell' der Schule 42 entwickeln wir ein vereinfachtes Shell-Programm. Diese Herausforderung ist entscheidend für unser Verständnis von Prozessen und Dateideskriptoren. Ziel ist es, eine minimalistische Bash-Version zu erstellen und sich so mit den Feinheiten der Shell-Programmierung vertraut zu machen. Wir konzentrieren uns auf grundlegende Aspekte wie die Verwaltung von Kommandoeingaben, die Handhabung von Dateiverzeichnissen, die Interpretation von Umgebungsvariablen und die Implementierung wesentlicher Funktionen wie Signalmanagement und Kommandosausführung. Das Projekt ist ein wichtiger Schritt zu einem tieferen Verständnis der Systemprogrammierung und bietet praktische Erfahrung mit Schlüsselkonzepten in Unix/Linux-Shell-Umgebungen.",
			"technologies": [
				"C",
				"Unix",
				"Shell"
			],
			"date": "Januar 2024",
			"repo": "https://github.com/aceyzz/Minishell",
			"logo": "/assets/projects/shell.png",
			"banner": "/assets/projects/banner/minishell.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Cub3D",
			"description": "Entwicklung eines 3D-Spiels inspiriert von Wolfenstein 3D mit Ray-Casting.",
			"detail": "Dieses Projekt besteht darin, ein 3D-Ego-Shooter-Spiel mit Ray-Casting-Technik zur Darstellung eines Labyrinths zu entwickeln. Das Spiel wird mit der Grafikbibliothek MiniLibX entwickelt und enthält Funktionen wie Spielerbewegung, Schießen und Texturverwaltung.",
			"technologies": [
				"C",
				"MiniLibX",
				"Ray-Casting"
			],
			"date": "Januar 2024",
			"repo": "https://github.com/aceyzz/cub3d",
			"logo": "/assets/projects/cube.png",
			"banner": "/assets/projects/banner/cub3d.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "NetPractice",
			"description": "Erlernen der grundlegenden Netzwerk-Konzepte.",
			"detail": "Das Projekt NetPractice ist eine spannende Herausforderung der Schule 42, die darauf abzielt, meine Fähigkeiten im Bereich Computernetzwerke zu vertiefen und praktisch anzuwenden. Es bietet eine einzigartige Gelegenheit, in die komplexe und faszinierende Welt der Netzwerke einzutauchen, indem ich lerne, Netzwerke zu konfigurieren, zu verwalten und Probleme in realen und simulierten Netzwerkumgebungen zu lösen. Ziele sind das Verständnis der Netzwerkgrundlagen, einschließlich OSI- und TCP/IP-Modell, die Beherrschung der Konfiguration und Verwaltung von Netzwerkgeräten wie Switches und Routern sowie die Anwendung von Troubleshooting-Techniken zur Identifikation und Lösung von Netzwerkproblemen.",
			"technologies": [
				"Netzwerk",
				"OSI-Modell",
				"TCP/IP",
				"Switches",
				"Router",
				"Fehlerbehebung"
			],
			"date": "Februar 2024",
			"repo": "https://github.com/aceyzz/NetPractice",
			"logo": "/assets/projects/ip.png",
			"banner": "/assets/projects/banner/netpractice.png",
			"category": [
				"Cybersicherheit & Netzwerk",
				"Projekte 42"
			]
		},
		{
			"title": "C++-Piscine (Teil 1)",
			"description": "Einführung in die objektorientierte Programmierung mit C++.",
			"detail": "Erlernen der Grundlagen der objektorientierten Programmierung mit C++. Fokus auf Klassen, Objekte und Modularität. Verständnis von Ad-hoc-Polymorphismus, Überladungen und kanonischen orthodoxen Klassen in C++. Lernen von Speicherallokation, Referenzen, Zeigern auf Mitglieder und der Verwendung von Switch in C++. Erforschung der Besonderheiten von C++ im Vergleich zu C mit einem Einblick in die objektorientierte Programmierung. Studium des Subtyp-Polymorphismus, abstrakter Klassen und Schnittstellen in C++. Verständnis der Vererbung in C++ und deren Bedeutung für die Entwicklung robuster und modularer Software.",
			"technologies": [
				"C++"
			],
			"date": "März 2024",
			"repo": "https://github.com/aceyzz/CPP-Part.1",
			"logo": "/assets/projects/cplusplus.png",
			"banner": "/assets/projects/banner/cpp1.png",
			"category": [
				"Objektorientierte Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "C++-Piscine (Teil 2)",
			"description": "Vertiefung fortgeschrittener C++-Konzepte.",
			"detail": "Vertiefung fortgeschrittener C++-Funktionen wie Templates, verschiedene Cast-Typen, Verwendung von Standard-Containern (STL), 'Template Containers', Iteratoren und 'Algorithms' sowie Ausnahmebehandlung mit Try/Catch-Blöcken. Das Projekt umfasst auch die Implementierung generischer Programmierkonzepte, die Verwendung von Smart Pointern und die Leistungsoptimierung durch fortgeschrittene Speicherverwaltungstechniken.",
			"technologies": [
				"C++"
			],
			"date": "März 2024",
			"repo": "https://github.com/aceyzz/CPP-Part.2",
			"logo": "/assets/projects/cplusplus.png",
			"banner": "/assets/projects/banner/cpp2.png",
			"category": [
				"Objektorientierte Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Inception",
			"description": "Bereitstellung einer komplexen und sicheren Web-Infrastruktur mit Docker.",
			"detail": "Im Rahmen unseres Studiums an der Schule 42 bearbeiten wir das Projekt 'Inception'. Dieses ambitionierte Projekt dient der Vertiefung und praktischen Anwendung der Kenntnisse in Virtualisierung und Containerverwaltung. Ziel ist die Bereitstellung einer komplexen und sicheren Infrastruktur, vollständig konfiguriert mit Docker und orchestriert mit docker-compose, alles in einer dedizierten virtuellen Maschine. Die Architektur umfasst mehrere Schlüsselkomponenten: einen Docker-Container mit NGINX, einen Container für WordPress + php-fpm, einen Container für MariaDB, zwei separate Volumes für die Datenbank und die Website-Dateien sowie ein spezifisches Docker-Netzwerk für die Kommunikation zwischen den Containern. Die Container müssen aus eigenen Dockerfiles gebaut werden, ohne vorgefertigte Images oder Dienste wie DockerHub.",
			"technologies": [
				"Docker",
				"WordPress",
				"MariaDB",
				"php-fpm",
				"Nginx",
				"TLS",
				"Docker Compose",
				"Virtualisierung"
			],
			"date": "März 2024",
			"repo": "https://github.com/aceyzz/Inception",
			"logo": "/assets/projects/inception.png",
			"banner": "/assets/projects/banner/inception.png",
			"category": [
				"Systeme & DevOps",
				"Cybersicherheit & Netzwerk",
				"Projekte 42"
			]
		},
		{
			"title": "Webserv",
			"description": "Implementierung eines Webservers in C++ nach dem HTTP-Protokoll.",
			"detail": "Das Projekt Webserv der Schule 42 besteht darin, einen Webserver in C++ nach dem Standard C++98 zu implementieren. Der Server muss statische Dateien ausliefern und CGI-Anfragen verarbeiten können. Er muss mehrere gleichzeitige Verbindungen und große Dateien asynchron und nicht-blockierend verwalten. Außerdem muss der Server die HTTP-Methoden GET, POST und DELETE sowie CGI-Anfragen für GET und POST unterstützen. Er muss Fehler verwalten und die entsprechenden HTTP-Statuscodes zurückgeben. Der Server muss auch Anfragen mit großen Headern und Bodies verwalten, mit einer im Konfigurationsfile definierten Grenze. Das Referenzverhalten für dieses Projekt ist das von Nginx.",
			"technologies": [
				"C++",
				"Netzwerk",
				"HTTP",
				"CGI",
				"Asynchrones I/O",
				"SSL"
			],
			"date": "August 2024",
			"repo": "https://github.com/aceyzz/webserv",
			"logo": "/assets/projects/web.png",
			"banner": "/assets/projects/banner/webserv.png",
			"category": [
				"Webentwicklung",
				"Objektorientierte Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Ft_Transcendence",
			"description": "Entwicklung einer vollständigen Webanwendung für ein Online-Multiplayer-Spiel.",
			"detail": "Entwicklung einer Webplattform für ein Echtzeit-Multiplayer-Spiel, einschließlich WebSocket. Das Projekt umfasst Benutzerverwaltung, lokalen und entfernten Multiplayer-Support, ein Turniersystem, Statistik-Tabellen und fortschrittliche Sicherheitsmaßnahmen wie Passwort-Hashing und Schutz vor XSS/SQL-Injection. Das Backend wird von einem eigenen Webmodul verwaltet, die Datenbank ist integriert und das Frontend verwendet JavaScript mit einem modernen Toolkit. Die Anwendung ist eine SPA, kompatibel mit Chrome, ohne Konsolenfehler und startet mit einem einzigen Befehl.",
			"technologies": [
				"HTML",
				"CSS",
				"JavaScript",
				"Django",
				"WebSocket",
				"PostgreSQL",
				"Docker",
				"Modsecurity",
				"Nginx",
				"HashiCorp Vault"
			],
			"date": "Oktober 2024",
			"repo": "https://github.com/aceyzz/ft_transcendence",
			"logo": "/assets/projects/pong.png",
			"banner": "/assets/projects/banner/transcendence.png",
			"category": [
				"Webentwicklung",
				"Cybersicherheit & Netzwerk",
				"Projekte 42"
			]
		},
		{
			"title": "Shell-Module",
			"description": "Einführung in Shell-Skripte und Unix-Kommandos.",
			"detail": "Dieses Projekt behandelt die Grundlagen des Shell-Skripts, die wichtigsten Unix-Kommandos und deren Anwendung in einer Linux-Umgebung. Ziel ist es, alltägliche Aufgaben zu automatisieren.",
			"technologies": [
				"Shell-Scripting",
				"Unix"
			],
			"date": "September 2023",
			"repo": "https://github.com/aceyzz/42-Piscine/tree/main/shell_modules",
			"logo": "/assets/projects/modules_shell.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "C-Module",
			"description": "Erste Grundlagen der Programmiersprache C, Logik und einfache Algorithmen.",
			"detail": "Erlernen der Grundlagen der Programmiersprache C, einschließlich Datenstrukturen, Schleifen und Funktionen. Die Projekte legen auch Wert auf algorithmische Logik und Compiler-Tools.",
			"technologies": [
				"C"
			],
			"date": "September 2023",
			"repo": "https://github.com/aceyzz/42-Piscine/tree/main/c_modules",
			"logo": "/assets/projects/modules_c.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		},
		{
			"title": "Rushes",
			"description": "Intensive Team-Challenges zur Lösung komplexer Probleme.",
			"detail": "Gemeinsame Arbeit an komplexen Herausforderungen mit kurzen Deadlines, um Problemlösungsfähigkeiten und Teamkommunikation zu verbessern.",
			"technologies": [
				"C",
				"Teamarbeit"
			],
			"date": "September 2023",
			"repo": "https://github.com/aceyzz/42-Piscine/tree/main/rushes",
			"logo": "/assets/projects/rushes.png",
			"category": [
				"Niedrig-Level-Programmierung",
				"Projekte 42"
			]
		}
	]
}